package httpmux

import (
	"os"
	"strings"

	"gopkg.in/yaml.v3"
)

// Config is the unified runtime config for RsTunnel (picotun).
//
// Goals:
//  1. Be fully compatible with DaggerConnect YAML schema (client/server defaults generated by `-gen`).
//  2. Keep backward compatibility with older RsTunnel keys (server_url, forward.tcp/udp, mimic/obfs).
//
// Practical notes:
//   - RsTunnel currently uses its own multiplexing + framing over HTTP(S) requests.
//     Fields like smux/kcp/advanced are loaded + preserved for compatibility, and can
//     be wired into runtime later.
//   - For client mode, Dagger-style `paths:` is preferred (multi-path). If empty,
//     legacy `server_url:` is accepted.
type Config struct {
	// Common
	Mode        string `yaml:"mode"`      // server|client
	Listen      string `yaml:"listen"`    // server: bind addr; client: usually empty
	Transport   string `yaml:"transport"` // httpmux/httpsmux/wsmux/wssmux/kcpmux/tcpmux
	PSK         string `yaml:"psk"`
	Profile     string `yaml:"profile"`
	Verbose     bool   `yaml:"verbose"`
	CertFile    string `yaml:"cert_file"`
	KeyFile     string `yaml:"key_file"`
	MaxSessions int    `yaml:"max_sessions"`
	Heartbeat   int    `yaml:"heartbeat"`

	// Dagger mappings
	Maps  []DaggerMap  `yaml:"maps"`  // server side port mappings
	Paths []PathConfig `yaml:"paths"` // client side multi-paths

	// Dagger tuning blocks
	Smux        SmuxConfig      `yaml:"smux"`
	KCP         KCPConfig       `yaml:"kcp"`
	Advanced    AdvancedConfig  `yaml:"advanced"`
	Obfuscation ObfsCompat      `yaml:"obfuscation"`
	HTTPMimic   HTTPMimicCompat `yaml:"http_mimic"`

	// --- RsTunnel native/legacy keys (still supported) ---
	// Client legacy single-url mode (full URL)
	ServerURL string `yaml:"server_url"`
	SessionID string `yaml:"session_id"`

	// Native forward mappings (legacy RsTunnel)
	Forward struct {
		TCP []string `yaml:"tcp"` // ["0.0.0.0:1457->127.0.0.1:1457"]
		UDP []string `yaml:"udp"`
	} `yaml:"forward"`

	// Native mimic/obfs blocks (aliases for dagger blocks)
	Mimic MimicConfig `yaml:"mimic"`
	Obfs  ObfsConfig  `yaml:"obfs"`

	// Legacy top-level session timeout (seconds)
	SessionTimeout int `yaml:"session_timeout"`
}

// PathConfig is a Dagger-like "connection path".
type PathConfig struct {
	Transport      string `yaml:"transport"`       // httpmux/httpsmux/wsmux/...
	Addr           string `yaml:"addr"`            // host:port OR full URL
	ConnectionPool int    `yaml:"connection_pool"` // default 2
	AggressivePool bool   `yaml:"aggressive_pool"` // default false
	RetryInterval  int    `yaml:"retry_interval"`  // seconds
	DialTimeout    int    `yaml:"dial_timeout"`    // seconds
}

// DaggerMap matches DaggerConnect `maps:` schema.
type DaggerMap struct {
	Type   string `yaml:"type"`   // tcp|udp|both
	Bind   string `yaml:"bind"`   // 0.0.0.0:1457
	Target string `yaml:"target"` // 127.0.0.1:1457
}

// SmuxConfig mirrors DaggerConnect schema (loaded for compatibility).
type SmuxConfig struct {
	KeepAlive int `yaml:"keepalive"`
	MaxRecv   int `yaml:"max_recv"`
	MaxStream int `yaml:"max_stream"`
	FrameSize int `yaml:"frame_size"`
	Version   int `yaml:"version"`
}

// KCPConfig mirrors DaggerConnect schema (loaded for compatibility).
type KCPConfig struct {
	NoDelay  int `yaml:"nodelay"`
	Interval int `yaml:"interval"`
	Resend   int `yaml:"resend"`
	NC       int `yaml:"nc"`
	SndWnd   int `yaml:"sndwnd"`
	RcvWnd   int `yaml:"rcvwnd"`
	MTU      int `yaml:"mtu"`
}

// AdvancedConfig mirrors DaggerConnect schema (loaded for compatibility).
// Only a subset is currently used by RsTunnel, but we parse & preserve everything.
type AdvancedConfig struct {
	TCPNoDelay           bool `yaml:"tcp_nodelay"`
	TCPKeepAlive         int  `yaml:"tcp_keepalive"`
	TCPReadBuffer        int  `yaml:"tcp_read_buffer"`
	TCPWriteBuffer       int  `yaml:"tcp_write_buffer"`
	WebSocketReadBuffer  int  `yaml:"websocket_read_buffer"`
	WebSocketWriteBuffer int  `yaml:"websocket_write_buffer"`
	WebSocketCompression bool `yaml:"websocket_compression"`
	CleanupInterval      int  `yaml:"cleanup_interval"`
	SessionTimeout       int  `yaml:"session_timeout"`
	ConnectionTimeout    int  `yaml:"connection_timeout"`
	StreamTimeout        int  `yaml:"stream_timeout"`
	MaxConnections       int  `yaml:"max_connections"`
	MaxUDPFlows          int  `yaml:"max_udp_flows"`
	UDPFlowTimeout       int  `yaml:"udp_flow_timeout"`
	UDPBufferSize        int  `yaml:"udp_buffer_size"`
}

// HTTPMimicCompat is DaggerConnect `http_mimic:` block.
type HTTPMimicCompat struct {
	FakeDomain      string   `yaml:"fake_domain"`
	FakePath        string   `yaml:"fake_path"`
	UserAgent       string   `yaml:"user_agent"`
	ChunkedEncoding bool     `yaml:"chunked_encoding"`
	SessionCookie   bool     `yaml:"session_cookie"`
	CustomHeaders   []string `yaml:"custom_headers"`
}

// ObfsCompat is DaggerConnect `obfuscation:` block.
type ObfsCompat struct {
	Enabled     bool    `yaml:"enabled"`
	MinPadding  int     `yaml:"min_padding"`
	MaxPadding  int     `yaml:"max_padding"`
	MinDelayMS  int     `yaml:"min_delay_ms"`
	MaxDelayMS  int     `yaml:"max_delay_ms"`
	BurstChance float64 `yaml:"burst_chance"`
}

func normalizePath(p string) string {
	p = strings.TrimSpace(p)
	if p == "" {
		return ""
	}
	if !strings.HasPrefix(p, "/") {
		p = "/" + p
	}
	return p
}

func applyDaggerDefaults(c *Config) {
	// Match DaggerConnect -gen defaults as close as possible.
	if strings.TrimSpace(c.Profile) == "" {
		c.Profile = "balanced"
	}
	if c.Heartbeat <= 0 {
		c.Heartbeat = 10
	}
	// Smux defaults
	if c.Smux.KeepAlive <= 0 {
		c.Smux.KeepAlive = 8
	}
	if c.Smux.MaxRecv <= 0 {
		c.Smux.MaxRecv = 8388608
	}
	if c.Smux.MaxStream <= 0 {
		c.Smux.MaxStream = 8388608
	}
	if c.Smux.FrameSize <= 0 {
		c.Smux.FrameSize = 32768
	}
	if c.Smux.Version <= 0 {
		c.Smux.Version = 2
	}
	// KCP defaults
	if c.KCP.NoDelay == 0 {
		c.KCP.NoDelay = 1
	}
	if c.KCP.Interval <= 0 {
		c.KCP.Interval = 10
	}
	if c.KCP.Resend <= 0 {
		c.KCP.Resend = 2
	}
	if c.KCP.NC == 0 {
		c.KCP.NC = 1
	}
	if c.KCP.SndWnd <= 0 {
		c.KCP.SndWnd = 1024
	}
	if c.KCP.RcvWnd <= 0 {
		c.KCP.RcvWnd = 1024
	}
	if c.KCP.MTU <= 0 {
		c.KCP.MTU = 1400
	}
	// Advanced defaults
	if c.Advanced.TCPKeepAlive <= 0 {
		c.Advanced.TCPKeepAlive = 15
	}
	if c.Advanced.TCPReadBuffer <= 0 {
		c.Advanced.TCPReadBuffer = 8388608
	}
	if c.Advanced.TCPWriteBuffer <= 0 {
		c.Advanced.TCPWriteBuffer = 8388608
	}
	if c.Advanced.WebSocketReadBuffer <= 0 {
		c.Advanced.WebSocketReadBuffer = 262144
	}
	if c.Advanced.WebSocketWriteBuffer <= 0 {
		c.Advanced.WebSocketWriteBuffer = 262144
	}
	if c.Advanced.CleanupInterval <= 0 {
		c.Advanced.CleanupInterval = 3
	}
	if c.Advanced.SessionTimeout <= 0 {
		c.Advanced.SessionTimeout = 30
	}
	if c.Advanced.ConnectionTimeout <= 0 {
		c.Advanced.ConnectionTimeout = 60
	}
	if c.Advanced.StreamTimeout <= 0 {
		c.Advanced.StreamTimeout = 120
	}
	if c.Advanced.MaxConnections <= 0 {
		c.Advanced.MaxConnections = 2000
	}
	if c.Advanced.MaxUDPFlows <= 0 {
		c.Advanced.MaxUDPFlows = 1000
	}
	if c.Advanced.UDPFlowTimeout <= 0 {
		c.Advanced.UDPFlowTimeout = 300
	}
	if c.Advanced.UDPBufferSize <= 0 {
		c.Advanced.UDPBufferSize = 4194304
	}
	// Obfuscation defaults
	if !c.Obfuscation.Enabled && !c.Obfs.Enabled {
		// Dagger defaults obfuscation enabled=true
		c.Obfuscation.Enabled = true
	}
	if c.Obfuscation.MinPadding <= 0 {
		c.Obfuscation.MinPadding = 16
	}
	if c.Obfuscation.MaxPadding <= 0 {
		c.Obfuscation.MaxPadding = 512
	}
	if c.Obfuscation.MinDelayMS < 0 {
		c.Obfuscation.MinDelayMS = 0
	}
	if c.Obfuscation.MaxDelayMS <= 0 {
		c.Obfuscation.MaxDelayMS = 50
	}
	if c.Obfuscation.BurstChance <= 0 {
		c.Obfuscation.BurstChance = 0.15
	}
	// http_mimic defaults
	if strings.TrimSpace(c.HTTPMimic.FakeDomain) == "" {
		c.HTTPMimic.FakeDomain = "www.google.com"
	}
	if strings.TrimSpace(c.HTTPMimic.FakePath) == "" {
		c.HTTPMimic.FakePath = "/search"
	}
	c.HTTPMimic.FakePath = normalizePath(c.HTTPMimic.FakePath)
	if strings.TrimSpace(c.HTTPMimic.UserAgent) == "" {
		c.HTTPMimic.UserAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
	}
	// Dagger default chunked=true, cookie=true
	if !c.HTTPMimic.ChunkedEncoding {
		c.HTTPMimic.ChunkedEncoding = true
	}
	if !c.HTTPMimic.SessionCookie {
		c.HTTPMimic.SessionCookie = true
	}
}

func syncAliases(c *Config) {
	// Prefer dagger blocks if present; otherwise fall back to native blocks.
	// Then keep native + dagger in sync so the rest of runtime can use Mimic/Obfs.

	// http mimic
	if c.Mimic.FakeDomain == "" && c.HTTPMimic.FakeDomain != "" {
		c.Mimic.FakeDomain = c.HTTPMimic.FakeDomain
	}
	if c.Mimic.FakePath == "" && c.HTTPMimic.FakePath != "" {
		c.Mimic.FakePath = c.HTTPMimic.FakePath
	}
	if c.Mimic.UserAgent == "" && c.HTTPMimic.UserAgent != "" {
		c.Mimic.UserAgent = c.HTTPMimic.UserAgent
	}
	if len(c.Mimic.CustomHeaders) == 0 && len(c.HTTPMimic.CustomHeaders) > 0 {
		c.Mimic.CustomHeaders = append([]string{}, c.HTTPMimic.CustomHeaders...)
	}
	if !c.Mimic.Chunked {
		c.Mimic.Chunked = c.HTTPMimic.ChunkedEncoding
	}
	if !c.Mimic.SessionCookie {
		c.Mimic.SessionCookie = c.HTTPMimic.SessionCookie
	}
	c.Mimic.FakePath = normalizePath(c.Mimic.FakePath)

	// obfuscation
	if !c.Obfs.Enabled {
		c.Obfs.Enabled = c.Obfuscation.Enabled
	}
	if c.Obfs.MinPadding <= 0 {
		c.Obfs.MinPadding = c.Obfuscation.MinPadding
	}
	if c.Obfs.MaxPadding <= 0 {
		c.Obfs.MaxPadding = c.Obfuscation.MaxPadding
	}
	if c.Obfs.MinDelayMS < 0 {
		c.Obfs.MinDelayMS = c.Obfuscation.MinDelayMS
	}
	if c.Obfs.MaxDelayMS <= 0 {
		c.Obfs.MaxDelayMS = c.Obfuscation.MaxDelayMS
	}
	if c.Obfs.BurstChance <= 0 {
		// ObfsConfig.BurstChance is int(0..1000)
		c.Obfs.BurstChance = int(c.Obfuscation.BurstChance * 1000)
	}
}

func LoadConfig(path string) (*Config, error) {
	b, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var c Config
	if err := yaml.Unmarshal(b, &c); err != nil {
		return nil, err
	}

	// Normalize strings
	c.Mode = strings.ToLower(strings.TrimSpace(c.Mode))
	c.Transport = strings.ToLower(strings.TrimSpace(c.Transport))
	c.Profile = strings.ToLower(strings.TrimSpace(c.Profile))
	c.Listen = strings.TrimSpace(c.Listen)
	c.ServerURL = strings.TrimSpace(c.ServerURL)
	c.SessionID = strings.TrimSpace(c.SessionID)
	c.HTTPMimic.FakePath = normalizePath(c.HTTPMimic.FakePath)
	c.Mimic.FakePath = normalizePath(c.Mimic.FakePath)

	// Defaults (Dagger-like)
	applyDaggerDefaults(&c)

	// Session timeout precedence:
	// advanced.session_timeout > session_timeout > default (already set by defaults)
	if c.Advanced.SessionTimeout > 0 {
		c.SessionTimeout = c.Advanced.SessionTimeout
	} else if c.SessionTimeout <= 0 {
		c.SessionTimeout = 30
	}

	// Convert dagger maps => legacy forward list if forward is empty
	if len(c.Forward.TCP) == 0 && len(c.Forward.UDP) == 0 && len(c.Maps) > 0 {
		for _, m := range c.Maps {
			t := strings.ToLower(strings.TrimSpace(m.Type))
			bind := strings.TrimSpace(m.Bind)
			target := strings.TrimSpace(m.Target)
			if bind == "" || target == "" {
				continue
			}
			entry := bind + "->" + target
			switch t {
			case "tcp":
				c.Forward.TCP = append(c.Forward.TCP, entry)
			case "udp":
				c.Forward.UDP = append(c.Forward.UDP, entry)
			case "both":
				c.Forward.TCP = append(c.Forward.TCP, entry)
				c.Forward.UDP = append(c.Forward.UDP, entry)
			default:
				c.Forward.TCP = append(c.Forward.TCP, entry)
			}
		}
	}

	// Keep mimic/obfs aliases in sync
	syncAliases(&c)

	// Reasonable defaults for RsTunnel
	if c.SessionID == "" {
		c.SessionID = "sess-default"
	}
	if c.Mode == "server" && c.Listen == "" {
		c.Listen = "0.0.0.0:2020"
	}

	return &c, nil
}
